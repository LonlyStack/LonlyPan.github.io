---
layout: post
title: "STM32F030 LL库笔记-STM32CubeIDE使用"
data: 2019-9-12 16:23
categories:  stm
---


**本文作者：** LonlyPan  
**本文链接：** [https://lonlypan.com/archivers/STM32F030-LL库使用笔记](https://lonlypan.com/archivers/STM32F030-LL库使用笔记)  
**版权声明：** 本文遵循 [署名-非商业性使用-禁止演绎 4.0 国际](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh) 协议。禁止用于商业用途，转载联系作者授权！

----------

## 为什么用LL库

标准库官方已经不更新了，虽然资料很多，所以不再使用。之后学习使用了HAL库，但最近做项目需要使用16和32KB的STM32F0芯片，使用HAL库新建个工程再加上串口，基本就是10KB+了，所以也是被迫重新选择了LL库。

下面是别人做的一个不同编程方式的效率对比：
原文链接：[https://blog.csdn.net/super828/article/details/79078693](https://blog.csdn.net/super828/article/details/79078693)

![标准库与Cube,LL,直接写寄存器的效率对比](https://raw.githubusercontent.com/LonlyPan/LonlyPan.github.io/master/images/Posts/STM32F030_LL库使用笔记/标准库与Cube,LL,直接写寄存器的效率对比.png)


总的来说：代码效率与移植性成反比的规律是明显的。与HAL相比，LL的效率优势很明显，几乎和直接写寄存器的效率相差无几。而且目前STM32cubeIDE已经支持直接生成LL工程，对于追求效率的开发应用人员来说，非常值得推荐大家使用。

## 1、软件

### 1.1 STM32CubeIDE介绍

官网地址：[STM32CubeIDE官网](https://www.stmicroelectronics.com.cn/en/development-tools/stm32cubeide.html)

STM32CubeIDE是一个多功能的集成开发工具，集成了TrueSTUDIO和STM32CubeMX，它是STM32Cube软件生态系统的一部分。简单来说就是：**STM32cubeIDE = true studio for stm32 + STM32cubeMX**

![STM32CubeIDE](https://raw.githubusercontent.com/LonlyPan/LonlyPan.github.io/master/images/Posts/STM32F030_LL库笔记-STM32CubeIDE使用/en.STM32CubeIDE.jpg)

STM32CubeIDE是一个先进的C/C++开发平台，具有STM32微控制器的IP配置，代码生成，代码编译和调试功能。

从选择的电路板中选择空的STM32 MCU或预配置的微控制器后，将创建项目并生成初始化代码。在开发期间的任何时候，用户可以返回到IP或中间件的初始化和配置，并重新生成初始化代码而不影响用户代码。

STM32CubeIDE包括构建和堆栈分析器，为用户提供有关项目状态和内存要求的有用信息。
STM32CubeIDE还包括标准和高级调试功能，包括CPU内核寄存器，存储器和外设寄存器的视图，以及实时可变监视，串行线查看器接口或故障分析器。

主要特点：

**1. 集成STM32CubeMX，提供以下服务：**
   - STM32微控制器选择 
   - 引脚分配，时钟，IP和中间件配置 
   - 项目创建和初始化代码的生成

**2. 基于Eclipse™/ CDT，支撑ECLIPSE的™插件，GNU C / C ++中ARM ®工具链和GDB调试器。**

**3. 其他高级调试功能包括：**
   - CPU内核，IP寄存器和内存视图
   - 实时变量观看视图
   - 系统分析和实时跟踪（SWV）
   - CPU故障分析工具

**4. 支持ST-LINK（STMicroelectronics）和J-Link（SEGGER）调试探针**   

**5. 从Atollic导入项目® TrueSTUDIO ®和AC6系统工作台的STM32**  

**6. 多支持操作系统：Windows ®，Linux的®和MacOS ®**

### 1.2 STM32cubeIDE下载安装

#### 1.2.1 下载
官网下载地址： [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html)  
在页面底部找到下图，根据自己电脑操作系统下载即可，这里以Windows版为例。  右边下拉菜单还可以选择其他版本，推荐下载最新版。
软件是免费的， 但下载时需要填写信息或者注册。  

![软件下载](https://raw.githubusercontent.com/LonlyPan/LonlyPan.github.io/master/images/Posts/STM32F030_LL库笔记-STM32CubeIDE使用/软件下载.png)

#### 1.2.2 安装

https://blog.csdn.net/chen18221987993/article/details/90897627  
http://www.luyixian.cn/news_show_72848.aspx  
https://mp.weixin.qq.com/s/w8cvEySdXs1a0kpK5wRoUw  

### 1.3 新建工程模板

新建工程有两种方法，如下图所示。方法2是在空项目情况下显示的快捷方式。

![新建工程](https://raw.githubusercontent.com/LonlyPan/LonlyPan.github.io/master/images/Posts/STM32F030_LL库使用笔记/新建工程.png)

https://blog.csdn.net/ybhuangfugui/article/details/89702356
https://www.strongerhuang.com/STM32Cube/STM32CubeMX/STM32CubeMX%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B03_%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%B7%A5%E7%A8%8B.html
https://www.strongerhuang.com/STM32Cube/STM32CubeMX/STM32CubeMX%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B04_STM32CubeMX%E5%90%84%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0.html
https://mp.weixin.qq.com/s?__biz=MzI4MDI4MDE5Ng==&mid=2247487135&idx=1&sn=befcd8aebe94c426181abc9a7eb49e63&chksm=ebbba374dccc2a62fbe758c656934d1f1b06b7427882ae5129f7afa1358d53674b66272c9dc7&mpshare=1&scene=21&srcid=&pass_ticket=mvZaxV8CBTwbJX1f8lVxdiRrDi5JMpgiXuPADHqY00AUxNhXi3wYjaFt8YuwpuWO#wechat_redirect

## 2、程序

### 2.1 GPIO操作

示例：
LL_mDelay(500); // 延时500ms

```
/**
   * @brief（简介） 在专用gpio端口上将几个引脚设置为高电平
   * @param（参数） GPIOx GPIO 端口
   * @param（参数） PinMask此参数可以是以下值的组合
   * @retval（返回值） 没有
   */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask){...}
```
示例：
`LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_3); // PB3输出高电平`

其他：
`LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_3); // PB3输出低电平`
`LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);    /* 翻转PB3输出电平`
`LL_GPIO_ReadInputPort(GPIO_TypeDef \*GPIOx);  /* 读取引脚电平状态 */`

USART

printf重定义

/* uart.c */
#ifdef __GNUC__
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch) /* 防⽌重定义， 具体为什么会⽤到GNUC我以
为不知道*/
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif
PUTCHAR_PROTOTYPE{
    //LL_USART_TransmitData8(USART1,Usart1_TxBuff[i]);
    USART1->TDR = ch;
    //while(!LL_USART_IsActiveFlag_TXE(USART1));
    while((USART1->ISR&0X40)==0);
return ch;
}
/* main.c*/
printf("233\n"); /* 串⼝打印数据 */
printf自己编写

/* uart.c */
#include "stdio.h"      //
#include "stdarg.h"        //
#include "string.h"     //
char Usart1_TxBuff[256];
void my_printf(char* fmt,...)
{
    unsigned int i,length;
    va_list ap;
    va_start(ap,fmt);
    vsprintf(Usart1_TxBuff,fmt,ap);
    va_end(ap);
    length=strlen((const char*)Usart1_TxBuff);
    while(!LL_USART_IsActiveFlag_TXE(USART1));
    //while((USART1->ISR&0X40)==0);
    for(i = 0; i < length; i ++)
    {
        
        LL_USART_TransmitData8(USART1,Usart1_TxBuff[i]);
        //USART1->TDR = Usart1_TxBuff[i];
        while(!LL_USART_IsActiveFlag_TXE(USART1));
        //while((USART1->ISR&0X40)==0);
    }
}
/* main.c*/
my_printf("233\n"); /* 串⼝打印数据 */
备注：
1、知识点：va_list

3、自己编写 printf 函数比重定义节省 0.46 KB，但RAM增加了。


其他发送方法

1、只发送字符串数据

/* uart.c中定义 */
void USART_Print(unsigned char *Send_Text,uint32_t Size_Text)
{
  uint32_t index = 0;
 
  for (index = 0; index < Size_Text; index++)
  {
    while (!LL_USART_IsActiveFlag_TXE(USART1));
     LL_USART_TransmitData8(USART1,Send_Text[index]);
  }
  while (!LL_USART_IsActiveFlag_TC(USART1));
}
/* 使用 */
USART_Print("Ready for Tx\r\n",(uint32_t) sizeof("Ready for Tx\r\n") );
一般接受中断

/* stm32f0xx_it.c声明中断函数 */
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */
    USART_RxIdleCallback();
  /* USER CODE END USART1_IRQn 0 */
  /* USER CODE BEGIN USART1_IRQn 1 */
  /* USER CODE END USART1_IRQn 1 */
}
/* uart.c中定义 */
void USART_RxIdleCallback(void)
{
    uint8_t tmp;
    if(LL_USART_IsActiveFlag_RXNE(USART1)) //接收中断
    {
        tmp=LL_USART_ReceiveData8(USART1);   //读取出来接收到的数据
        LL_USART_TransmitData8(USART1,tmp);  //把数据再从串口发送出去
    }
}
/* uart.h声明 */
void USART_RxIdleCallback(void);
/* 使用 */
// main.c初始化使能接受中断
LL_USART_EnableIT_RXNE(USART1);
DMA接受中断


/* uart.c中定义 */
void USART_DMA_CONFIG(void)
{
    LL_DMA_SetPeriphAddress(DMA1, LL_DMA_CHANNEL_5, (uint32_t)(&USART1->RDR));// LL_USART_DMA_GetRegAddr(USART1->DR));
    LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_5, (uint32_t)Usart1_RxBuff);
    LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_5, 255);
    LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_5);
    LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_5);
    LL_USART_EnableDMAReq_RX(USART1);
    LL_USART_EnableIT_IDLE(USART1);
}
void USART_RxIdleCallback(void)
{
    uint8_t cnt;
    if(LL_USART_IsActiveFlag_IDLE(USART1))
    {
        LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_5); //
        cnt = LL_DMA_GetDataLength(DMA1,LL_DMA_CHANNEL_5);
        u1_printf("data len is:%d\r\n",cnt);
        u1_printf("data rx is:%s\r\n",Usart1_RxBuff);
        LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_5, 255); 
        LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_5);
        LL_USART_ClearFlag_IDLE(USART1);
    }
}
/* uart.h声明 */
void USART_RxIdleCallback(void);
/* 使用 */
// main.c初始化DMA
USART_DMA_CONFIG();
备注：
不可使用DMA3，会出现 "VDD VALUE" redefined 错误。
只要配置了DMA，延时函数LL_mDelay()失效

总结

ADC

MX配置


内存占用对比


HAL_ADCEx_Calibration_Start(&hadc);
HAL_ADC_Start(&hadc);
uint16_t ADC_temp1=0;
HAL_ADC_PollForConversion(&hadc,10);
if(HAL_IS_BIT_SET(HAL_ADC_GetState(&hadc),HAL_ADC_STATE_REG_EOC))
    ADC_temp1=HAL_ADC_GetValue(&hadc);//0-4095
return ADC_temp1;
float updateTemperaturesFromRawValues(void)
{
static unsigned char temp_count = 0;
static unsigned long raw_temp_0_value = 0;

  temp_count++;
  raw_temp_0_value +=(ADC_Demo2()>>2);
  if(temp_count >= 16) // per 16 times 锛宑aculate once temp
  {
      temp_count = 0;
      current_temperature = analogtemp(raw_temp_0_value);
  }
  return current_temperature;
}
